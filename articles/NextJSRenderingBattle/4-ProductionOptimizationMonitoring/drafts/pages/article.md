# å®Ÿæˆ¦æŠ•å…¥ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚° - Next.jsæœ€é€Ÿãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®æ”»é˜² #4

## ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³é‹ç”¨ã§å­¦ã‚“ã ã“ã¨

èª­è€…ã®çš†æ§˜ã€ã„ã¤ã‚‚ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ã¤ã„ã«ã‚·ãƒªãƒ¼ã‚ºæœ€çµ‚å›ã¨ãªã‚Šã¾ã—ãŸã€‚ã“ã‚Œã¾ã§Next.jsæ–°ä¸–ä»£ã¸ã®ç§»è¡Œã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ‰‹æ³•ã®é¸æŠã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®å®Ÿè£…ã«ã¤ã„ã¦å­¦ã‚“ã§ãã¾ã—ãŸãŒã€ä»Šå›ã¯å®Ÿéš›ã®æœ¬ç•ªç’°å¢ƒã§ã®é‹ç”¨ã«ã¤ã„ã¦è©³ã—ããŠè©±ã—ã•ã›ã¦ã„ãŸã ãã¾ã™ã­ã€‚

å…ˆæœˆã€ã‚ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã‚’æœ¬ç•ªé©ç”¨ã—ãŸéš›ã€ã€Œé–‹ç™ºç’°å¢ƒã§ã¯å®Œç’§ã ã£ãŸã®ã«ã€æœ¬ç•ªã§æƒ³å®šå¤–ã®å•é¡ŒãŒ...ã€ã¨ã„ã†ã“ã¨ãŒã‚ã‚Šã¾ã—ãŸã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã•ã‚“ã®åˆ©ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚„è² è·ã®å¤‰å‹•ã¯ã€é–‹ç™ºç’°å¢ƒã§ã¯å†ç¾ã—ãã‚Œãªã„ã‚‚ã®ãªã‚“ã§ã™ã‚ˆã­ã€‚

ã§ã‚‚ã€é©åˆ‡ãªç›£è¦–ä½“åˆ¶ã¨ç¶™ç¶šçš„æ”¹å–„ã®ä»•çµ„ã¿ãŒã‚ã‚Œã°ã€ã‚€ã—ã‚æœ¬ç•ªç’°å¢ƒã®æ–¹ãŒå­¦ã³ã®å®åº«ã«ãªã‚Šã¾ã™ã€‚ä»Šå›ã¯ã€dev.toç´šã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å®‰å®šã—ã¦ç¶­æŒã™ã‚‹ãŸã‚ã®å®Ÿè·µçš„ãªé‹ç”¨æ‰‹æ³•ã‚’ã€å›³è§£ã¨ã¨ã‚‚ã«ã”ç´¹ä»‹ã—ã¾ã™ã€‚

ã‚‚ã—é‹ç”¨ãŒè¤‡é›‘ã«æ„Ÿã˜ã‚‰ã‚ŒãŸã‚‰ã”ã‚ã‚“ãªã•ã„ã€ã§ã‚‚æ®µéšçš„ã«æ§‹ç¯‰ã™ã‚Œã°ã€å¿…ãšå®‰å®šã—ãŸé«˜é€Ÿã‚µã‚¤ãƒˆã‚’ç¶­æŒã—ã¦ã„ãŸã ã‘ã‚‹ã¨æ€ã„ã¾ã™ã€‚

## ğŸ“ˆ ã‚·ãƒªãƒ¼ã‚ºé€²æ—çŠ¶æ³
- âœ… **ç¬¬1å›**: Next.jsæ–°ä¸–ä»£æ©Ÿèƒ½ã®ç†è§£ã¨æ®µéšçš„ç§»è¡Œæˆ¦ç•¥
- âœ… **ç¬¬2å›**: CSR/SSR/SSG/ISRé¸æŠåŸºæº–ã¨styled-componentsæœ€é©åŒ–
- âœ… **ç¬¬3å›**: dev.toç´šãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å®Ÿç¾ã®å…·ä½“çš„å®Ÿè£…æ‰‹æ³•
- ğŸ¯ **ä»Šå›ã®å­¦ç¿’é …ç›®**: æœ¬ç•ªç’°å¢ƒã§ã®å®‰å®šé‹ç”¨ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ä½“åˆ¶

### ä»Šå›ä½œæˆãƒ»æ‹¡å¼µã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«
- ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­å®š
- ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
- è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç¶™ç¶šæ”¹å–„ãƒ•ãƒ­ãƒ¼

## ğŸ”„ å‰å›ã‹ã‚‰ã®ç¶™ç¶š

### å‰è¨˜äº‹ã§ä½œæˆæ¸ˆã¿ã®å†…å®¹
- ç”»åƒæœ€é©åŒ–ã€ã‚³ãƒ¼ãƒ‰åˆ†å‰²ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã€ãƒãƒ³ãƒ‰ãƒ«æœ€é©åŒ–ã®å®Ÿè£…
- Core Web Vitalsæ¸¬å®šã‚·ã‚¹ãƒ†ãƒ 
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã®åŸºç¤è¨­å®š

### ä»Šå›ã®æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ
- æœ¬ç•ªç’°å¢ƒã§ã®å®Ÿéš›ã®é‹ç”¨ä½“åˆ¶æ§‹ç¯‰
- äºˆæœŸã—ãªã„å•é¡Œã¸ã®å¯¾å¿œç­–
- é•·æœŸçš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç¶­æŒæˆ¦ç•¥

## ã¯ã˜ã‚ã«

dev.toã®ã‚ˆã†ãªé«˜é€Ÿã‚µã‚¤ãƒˆã¯ã€ä¸€åº¦æœ€é©åŒ–ã™ã‚Œã°çµ‚ã‚ã‚Šã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚**ç¶™ç¶šçš„ãªç›£è¦–ã€è¿…é€Ÿãªå•é¡Œå¯¾å¿œã€å®šæœŸçš„ãªæ”¹å–„**ãŒå¿…è¦ã§ã™ã€‚

æœ¬ç•ªç’°å¢ƒã§ã¯ã€é–‹ç™ºæ™‚ã«ã¯æƒ³åƒã§ããªã‹ã£ãŸæ§˜ã€…ãªèª²é¡ŒãŒç™ºç”Ÿã—ã¾ã™ã€‚ã§ã‚‚ã€ãã‚Œã‚‰ã‚’äºˆæ¸¬ã—ã€é©åˆ‡ã«å¯¾å‡¦ã™ã‚‹ä»•çµ„ã¿ã‚’æ§‹ç¯‰ã™ã‚Œã°ã€å®‰å®šã—ãŸãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’é•·æœŸé–“ç¶­æŒã§ãã¾ã™ã€‚ã¤ã¾ã‚Šã€é‹ç”¨ã“ããŒçœŸã®æŠ€è¡“åŠ›ã‚’ç™ºæ®ã™ã‚‹å ´é¢ã£ã¦ã‚ã‘ã­ã€‚

ä»Šå›ã¯ã€å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ç’°å¢ƒã§ä½¿ãˆã‚‹å…·ä½“çš„ãªæ‰‹æ³•ã‚’ãŠä¼ãˆã—ã¾ã™ã€‚

## æœ¬ç•ªç’°å¢ƒç›£è¦–ä½“åˆ¶ã®æ§‹ç¯‰

*[å›³è§£1: ç·åˆç›£è¦–ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£]*
*ãƒ¦ãƒ¼ã‚¶ãƒ¼ â†’ CDN â†’ ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ â†’ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ â†’ å„å±¤ã§ã®ç›£è¦–ãƒã‚¤ãƒ³ãƒˆ*

### 1. ãƒªã‚¢ãƒ«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ï¼ˆRUMï¼‰

**Next.js ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã®RUMå®Ÿè£…**

```typescript
// lib/rum-monitoring.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

interface RUMData {
  sessionId: string;
  userId?: string;
  url: string;
  userAgent: string;
  timestamp: number;
  metrics: WebVitalMetrics;
  context: {
    deviceType: 'desktop' | 'mobile' | 'tablet';
    connectionType?: string;
    viewport: { width: number; height: number };
    timezone: string;
    language: string;
  };
}

interface WebVitalMetrics {
  FCP?: { value: number; rating: string; delta: number };
  LCP?: { value: number; rating: string; delta: number };
  CLS?: { value: number; rating: string; delta: number };
  FID?: { value: number; rating: string; delta: number };
  TTFB?: { value: number; rating: string; delta: number };
}

class RealUserMonitoring {
  private sessionId: string;
  private userId?: string;
  private buffer: RUMData[] = [];
  private batchSize = 10;
  private flushInterval = 30000; // 30ç§’

  constructor() {
    this.sessionId = this.generateSessionId();
    this.startBatchReporting();
  }

  private generateSessionId(): string {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2);
  }

  private getDeviceType(): 'desktop' | 'mobile' | 'tablet' {
    if (typeof window === 'undefined') return 'desktop';
    
    const width = window.innerWidth;
    if (width < 768) return 'mobile';
    if (width < 1024) return 'tablet';
    return 'desktop';
  }

  private getConnectionType(): string | undefined {
    if (typeof navigator !== 'undefined' && 'connection' in navigator) {
      const connection = (navigator as any).connection;
      return connection?.effectiveType || connection?.type;
    }
    return undefined;
  }

  public setUserId(userId: string): void {
    this.userId = userId;
  }

  public startMonitoring(): void {
    // Core Web Vitals ã®æ¸¬å®šé–‹å§‹
    getCLS((metric) => this.recordMetric('CLS', metric));
    getFID((metric) => this.recordMetric('FID', metric));
    getFCP((metric) => this.recordMetric('FCP', metric));
    getLCP((metric) => this.recordMetric('LCP', metric));
    getTTFB((metric) => this.recordMetric('TTFB', metric));

    // ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®æ¸¬å®š
    this.measureCustomMetrics();
  }

  private recordMetric(name: string, metric: any): void {
    const rumData: RUMData = {
      sessionId: this.sessionId,
      userId: this.userId,
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now(),
      metrics: { [name]: metric },
      context: {
        deviceType: this.getDeviceType(),
        connectionType: this.getConnectionType(),
        viewport: { 
          width: window.innerWidth, 
          height: window.innerHeight 
        },
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        language: navigator.language
      }
    };

    this.buffer.push(rumData);

    // ãƒãƒƒãƒ•ã‚¡ãŒæº€æ¯ã«ãªã£ãŸã‚‰å³åº§ã«é€ä¿¡
    if (this.buffer.length >= this.batchSize) {
      this.flushBuffer();
    }
  }

  private measureCustomMetrics(): void {
    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚é–“
    window.addEventListener('load', () => {
      const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
      this.recordCustomMetric('PAGE_LOAD_TIME', loadTime);
    });

    // JavaScript ã‚¨ãƒ©ãƒ¼ã®ç›£è¦–
    window.addEventListener('error', (event) => {
      this.recordError({
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      });
    });

    // Promise rejection ã®ç›£è¦–
    window.addEventListener('unhandledrejection', (event) => {
      this.recordError({
        message: 'Unhandled Promise Rejection',
        reason: event.reason
      });
    });
  }

  private recordCustomMetric(name: string, value: number): void {
    // ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨˜éŒ²
    fetch('/api/monitoring/custom-metrics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sessionId: this.sessionId,
        userId: this.userId,
        metricName: name,
        value,
        timestamp: Date.now()
      })
    }).catch(error => {
      console.error('Failed to record custom metric:', error);
    });
  }

  private recordError(error: any): void {
    fetch('/api/monitoring/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sessionId: this.sessionId,
        userId: this.userId,
        error,
        url: window.location.href,
        timestamp: Date.now()
      })
    }).catch(err => {
      console.error('Failed to record error:', err);
    });
  }

  private startBatchReporting(): void {
    setInterval(() => {
      if (this.buffer.length > 0) {
        this.flushBuffer();
      }
    }, this.flushInterval);

    // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã«ãƒãƒƒãƒ•ã‚¡ã‚’é€ä¿¡
    window.addEventListener('beforeunload', () => {
      this.flushBuffer(true);
    });
  }

  private flushBuffer(useBeacon: boolean = false): void {
    if (this.buffer.length === 0) return;

    const data = JSON.stringify({ metrics: [...this.buffer] });
    
    if (useBeacon && navigator.sendBeacon) {
      // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã¯ sendBeacon ã‚’ä½¿ç”¨
      navigator.sendBeacon('/api/monitoring/rum', data);
    } else {
      // é€šå¸¸æ™‚ã¯ fetch ã‚’ä½¿ç”¨
      fetch('/api/monitoring/rum', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: data,
        keepalive: true
      }).catch(error => {
        console.error('Failed to send RUM data:', error);
      });
    }

    this.buffer = [];
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
export const rumMonitoring = new RealUserMonitoring();

// React Hook ã¨ã—ã¦ä½¿ç”¨
export function useRealUserMonitoring(userId?: string) {
  useEffect(() => {
    if (userId) {
      rumMonitoring.setUserId(userId);
    }
    rumMonitoring.startMonitoring();
  }, [userId]);
}
```

### 2. ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ç›£è¦–

**Next.js API Routes ã§ã®ç›£è¦–å®Ÿè£…**

```typescript
// pages/api/monitoring/health.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { connectToDatabase } from '@/lib/database';
import { checkRedisConnection } from '@/lib/redis';
import { verifyExternalAPIs } from '@/lib/external-apis';

interface HealthCheckResult {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: number;
  uptime: number;
  version: string;
  checks: {
    database: { status: string; responseTime: number };
    cache: { status: string; responseTime: number };
    externalAPIs: { status: string; responseTime: number };
    memory: { used: number; total: number; percentage: number };
    cpu: { percentage: number };
  };
}

export default async function healthCheckHandler(
  req: NextApiRequest,
  res: NextApiResponse<HealthCheckResult>
) {
  const startTime = Date.now();
  
  try {
    // ä¸¦åˆ—ã§ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
    const [databaseCheck, cacheCheck, externalAPICheck] = await Promise.allSettled([
      checkDatabase(),
      checkCache(),
      checkExternalAPIs()
    ]);

    const memoryUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();

    const result: HealthCheckResult = {
      status: determineOverallStatus([databaseCheck, cacheCheck, externalAPICheck]),
      timestamp: Date.now(),
      uptime: process.uptime(),
      version: process.env.APP_VERSION || '1.0.0',
      checks: {
        database: getCheckResult(databaseCheck),
        cache: getCheckResult(cacheCheck),
        externalAPIs: getCheckResult(externalAPICheck),
        memory: {
          used: Math.round(memoryUsage.heapUsed / 1024 / 1024),
          total: Math.round(memoryUsage.heapTotal / 1024 / 1024),
          percentage: Math.round((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100)
        },
        cpu: {
          percentage: Math.round((cpuUsage.user + cpuUsage.system) / 1000000 * 100)
        }
      }
    };

    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ã‚’ãƒ˜ãƒƒãƒ€ãƒ¼ã«è¨­å®š
    res.setHeader('X-Response-Time', `${Date.now() - startTime}ms`);
    
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰
    const httpStatus = result.status === 'healthy' ? 200 : 
                      result.status === 'degraded' ? 200 : 503;
    
    res.status(httpStatus).json(result);
  } catch (error) {
    console.error('Health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      timestamp: Date.now(),
      uptime: process.uptime(),
      version: process.env.APP_VERSION || '1.0.0',
      checks: {
        database: { status: 'error', responseTime: -1 },
        cache: { status: 'error', responseTime: -1 },
        externalAPIs: { status: 'error', responseTime: -1 },
        memory: { used: 0, total: 0, percentage: 0 },
        cpu: { percentage: 0 }
      }
    });
  }
}

async function checkDatabase(): Promise<{ status: string; responseTime: number }> {
  const start = Date.now();
  try {
    const db = await connectToDatabase();
    await db.collection('health').findOne({});
    return { status: 'healthy', responseTime: Date.now() - start };
  } catch (error) {
    return { status: 'unhealthy', responseTime: Date.now() - start };
  }
}

async function checkCache(): Promise<{ status: string; responseTime: number }> {
  const start = Date.now();
  try {
    await checkRedisConnection();
    return { status: 'healthy', responseTime: Date.now() - start };
  } catch (error) {
    return { status: 'unhealthy', responseTime: Date.now() - start };
  }
}

async function checkExternalAPIs(): Promise<{ status: string; responseTime: number }> {
  const start = Date.now();
  try {
    await verifyExternalAPIs();
    return { status: 'healthy', responseTime: Date.now() - start };
  } catch (error) {
    return { status: 'degraded', responseTime: Date.now() - start };
  }
}

function getCheckResult(result: PromiseSettledResult<any>) {
  if (result.status === 'fulfilled') {
    return result.value;
  }
  return { status: 'error', responseTime: -1 };
}

function determineOverallStatus(checks: PromiseSettledResult<any>[]): 'healthy' | 'degraded' | 'unhealthy' {
  const results = checks.map(check => 
    check.status === 'fulfilled' ? check.value.status : 'error'
  );

  if (results.every(status => status === 'healthy')) return 'healthy';
  if (results.some(status => status === 'unhealthy' || status === 'error')) return 'unhealthy';
  return 'degraded';
}
```

*[å›³è§£2: ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ•ãƒ­ãƒ¼]*
*API â†’ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ â†’ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ â†’ å¤–éƒ¨API â†’ ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ â†’ ç·åˆåˆ¤å®š*

### 3. ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

**æ®µéšçš„ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š**

```typescript
// lib/alerting-system.ts
interface AlertRule {
  id: string;
  name: string;
  metric: string;
  condition: 'gt' | 'lt' | 'eq';
  threshold: number;
  duration: number; // ç¶™ç¶šæ™‚é–“ï¼ˆç§’ï¼‰
  severity: 'critical' | 'warning' | 'info';
  channels: ('email' | 'slack' | 'webhook')[];
  enabled: boolean;
}

interface AlertEvent {
  ruleId: string;
  timestamp: number;
  value: number;
  severity: string;
  message: string;
  context: Record<string, any>;
}

class AlertingSystem {
  private rules: AlertRule[] = [];
  private activeAlerts: Map<string, AlertEvent> = new Map();
  private alertHistory: AlertEvent[] = [];

  constructor() {
    this.loadDefaultRules();
    this.startMonitoring();
  }

  private loadDefaultRules(): void {
    this.rules = [
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é–¢é€£ã‚¢ãƒ©ãƒ¼ãƒˆ
      {
        id: 'lcp-critical',
        name: 'LCP Critical Threshold',
        metric: 'web_vitals_lcp',
        condition: 'gt',
        threshold: 4000, // 4ç§’è¶…é
        duration: 300, // 5åˆ†ç¶™ç¶š
        severity: 'critical',
        channels: ['email', 'slack'],
        enabled: true
      },
      {
        id: 'fcp-warning',
        name: 'FCP Warning Threshold',
        metric: 'web_vitals_fcp',
        condition: 'gt',
        threshold: 3000, // 3ç§’è¶…é
        duration: 600, // 10åˆ†ç¶™ç¶š
        severity: 'warning',
        channels: ['slack'],
        enabled: true
      },
      
      // ã‚µãƒ¼ãƒãƒ¼é–¢é€£ã‚¢ãƒ©ãƒ¼ãƒˆ
      {
        id: 'memory-critical',
        name: 'Memory Usage Critical',
        metric: 'system_memory_percentage',
        condition: 'gt',
        threshold: 90, // 90%è¶…é
        duration: 180, // 3åˆ†ç¶™ç¶š
        severity: 'critical',
        channels: ['email', 'slack', 'webhook'],
        enabled: true
      },
      {
        id: 'response-time-warning',
        name: 'API Response Time Warning',
        metric: 'api_response_time',
        condition: 'gt',
        threshold: 1000, // 1ç§’è¶…é
        duration: 300, // 5åˆ†ç¶™ç¶š
        severity: 'warning',
        channels: ['slack'],
        enabled: true
      },

      // ã‚¨ãƒ©ãƒ¼é–¢é€£ã‚¢ãƒ©ãƒ¼ãƒˆ
      {
        id: 'error-rate-critical',
        name: 'Error Rate Critical',
        metric: 'error_rate_percentage',
        condition: 'gt',
        threshold: 5, // 5%è¶…é
        duration: 60, // 1åˆ†ç¶™ç¶š
        severity: 'critical',
        channels: ['email', 'slack'],
        enabled: true
      }
    ];
  }

  public evaluateMetric(metricName: string, value: number, context: Record<string, any> = {}): void {
    const applicableRules = this.rules.filter(rule => 
      rule.metric === metricName && rule.enabled
    );

    for (const rule of applicableRules) {
      const isTriggered = this.evaluateCondition(rule, value);
      const alertKey = `${rule.id}_${metricName}`;

      if (isTriggered) {
        if (!this.activeAlerts.has(alertKey)) {
          // æ–°ã—ã„ã‚¢ãƒ©ãƒ¼ãƒˆã®é–‹å§‹
          const alert: AlertEvent = {
            ruleId: rule.id,
            timestamp: Date.now(),
            value,
            severity: rule.severity,
            message: this.generateAlertMessage(rule, value, context),
            context
          };

          this.activeAlerts.set(alertKey, alert);
          
          // ç¶™ç¶šæ™‚é–“å¾Œã«ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
          setTimeout(() => {
            if (this.activeAlerts.has(alertKey)) {
              this.triggerAlert(rule, alert);
            }
          }, rule.duration * 1000);
        }
      } else {
        // æ¡ä»¶ãŒæº€ãŸã•ã‚Œãªããªã£ãŸå ´åˆã€ã‚¢ãƒ©ãƒ¼ãƒˆã‚’è§£é™¤
        if (this.activeAlerts.has(alertKey)) {
          this.resolveAlert(alertKey);
        }
      }
    }
  }

  private evaluateCondition(rule: AlertRule, value: number): boolean {
    switch (rule.condition) {
      case 'gt': return value > rule.threshold;
      case 'lt': return value < rule.threshold;
      case 'eq': return value === rule.threshold;
      default: return false;
    }
  }

  private generateAlertMessage(rule: AlertRule, value: number, context: Record<string, any>): string {
    const contextStr = Object.keys(context).length > 0 
      ? `\nContext: ${JSON.stringify(context, null, 2)}`
      : '';

    return `ğŸš¨ ${rule.name}
    
Metric: ${rule.metric}
Current Value: ${value}
Threshold: ${rule.threshold}
Severity: ${rule.severity.toUpperCase()}
Time: ${new Date().toISOString()}${contextStr}`;
  }

  private async triggerAlert(rule: AlertRule, alert: AlertEvent): Promise<void> {
    console.log(`Triggering alert: ${rule.name}`);
    
    // ã‚¢ãƒ©ãƒ¼ãƒˆå±¥æ­´ã«è¿½åŠ 
    this.alertHistory.push(alert);

    // å„ãƒãƒ£ãƒ³ãƒãƒ«ã«é€šçŸ¥é€ä¿¡
    for (const channel of rule.channels) {
      try {
        await this.sendNotification(channel, alert);
      } catch (error) {
        console.error(`Failed to send alert to ${channel}:`, error);
      }
    }
  }

  private async sendNotification(channel: string, alert: AlertEvent): Promise<void> {
    switch (channel) {
      case 'email':
        await this.sendEmailAlert(alert);
        break;
      case 'slack':
        await this.sendSlackAlert(alert);
        break;
      case 'webhook':
        await this.sendWebhookAlert(alert);
        break;
    }
  }

  private async sendEmailAlert(alert: AlertEvent): Promise<void> {
    // ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã®å®Ÿè£…
    const emailData = {
      to: process.env.ALERT_EMAIL_RECIPIENTS?.split(',') || [],
      subject: `Alert: ${alert.severity.toUpperCase()} - ${alert.ruleId}`,
      body: alert.message
    };

    await fetch('/api/notifications/email', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(emailData)
    });
  }

  private async sendSlackAlert(alert: AlertEvent): Promise<void> {
    // Slacké€šçŸ¥ã®å®Ÿè£…
    const slackData = {
      channel: process.env.SLACK_ALERT_CHANNEL || '#alerts',
      text: alert.message,
      color: alert.severity === 'critical' ? 'danger' : 'warning'
    };

    await fetch(process.env.SLACK_WEBHOOK_URL!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(slackData)
    });
  }

  private async sendWebhookAlert(alert: AlertEvent): Promise<void> {
    // Webhooké€šçŸ¥ã®å®Ÿè£…
    await fetch(process.env.ALERT_WEBHOOK_URL!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(alert)
    });
  }

  private resolveAlert(alertKey: string): void {
    const alert = this.activeAlerts.get(alertKey);
    if (alert) {
      console.log(`Resolving alert: ${alertKey}`);
      this.activeAlerts.delete(alertKey);
      
      // è§£æ±ºé€šçŸ¥ã®é€ä¿¡ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
      // this.sendResolutionNotification(alert);
    }
  }

  private startMonitoring(): void {
    // å®šæœŸçš„ãªãƒ¡ãƒˆãƒªã‚¯ã‚¹è©•ä¾¡ï¼ˆä¾‹ï¼šRUMãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ï¼‰
    setInterval(() => {
      this.checkActiveAlerts();
    }, 60000); // 1åˆ†é–“éš”
  }

  private checkActiveAlerts(): void {
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ©ãƒ¼ãƒˆã®çŠ¶æ…‹ç¢ºèª
    for (const [key, alert] of this.activeAlerts.entries()) {
      const rule = this.rules.find(r => r.id === alert.ruleId);
      if (rule && Date.now() - alert.timestamp > rule.duration * 1000) {
        // ç¶™ç¶šæ™‚é–“ã‚’è¶…ãˆãŸå ´åˆã®ã¿ã‚¢ãƒ©ãƒ¼ãƒˆã‚’é€ä¿¡
        this.triggerAlert(rule, alert);
      }
    }
  }

  public getActiveAlerts(): AlertEvent[] {
    return Array.from(this.activeAlerts.values());
  }

  public getAlertHistory(limit: number = 100): AlertEvent[] {
    return this.alertHistory.slice(-limit);
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
export const alertingSystem = new AlertingSystem();
```

*[å›³è§£3: ã‚¢ãƒ©ãƒ¼ãƒˆç®¡ç†ãƒ•ãƒ­ãƒ¼]*
*ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›† â†’ é–¾å€¤åˆ¤å®š â†’ ç¶™ç¶šæ™‚é–“ãƒã‚§ãƒƒã‚¯ â†’ é€šçŸ¥é€ä¿¡ â†’ è§£æ±ºç¢ºèª*

## ç¶™ç¶šçš„ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥

### 1. æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ

```typescript
// lib/deployment-strategy.ts
interface DeploymentConfig {
  strategy: 'blue-green' | 'canary' | 'rolling';
  stages: DeploymentStage[];
  rollbackTriggers: RollbackTrigger[];
  monitoring: MonitoringConfig;
}

interface DeploymentStage {
  name: string;
  percentage: number; // ã‚«ãƒŠãƒªã‚¢é…ä¿¡æ™‚ã®ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯å‰²åˆ
  duration: number; // æ®µéšã®ç¶™ç¶šæ™‚é–“ï¼ˆåˆ†ï¼‰
  successCriteria: SuccessCriteria[];
}

interface SuccessCriteria {
  metric: string;
  threshold: number;
  operator: 'lt' | 'gt' | 'eq';
}

interface RollbackTrigger {
  metric: string;
  threshold: number;
  duration: number; // ç¶™ç¶šæ™‚é–“ï¼ˆç§’ï¼‰
}

class DeploymentManager {
  private config: DeploymentConfig;
  private currentDeployment: {
    id: string;
    stage: number;
    startTime: number;
    metrics: Record<string, number[]>;
  } | null = null;

  constructor(config: DeploymentConfig) {
    this.config = config;
  }

  public async startDeployment(deploymentId: string): Promise<void> {
    console.log(`Starting deployment: ${deploymentId}`);
    
    this.currentDeployment = {
      id: deploymentId,
      stage: 0,
      startTime: Date.now(),
      metrics: {}
    };

    await this.executeStage(0);
  }

  private async executeStage(stageIndex: number): Promise<void> {
    if (stageIndex >= this.config.stages.length) {
      console.log('Deployment completed successfully');
      this.currentDeployment = null;
      return;
    }

    const stage = this.config.stages[stageIndex];
    console.log(`Executing stage: ${stage.name} (${stage.percentage}% traffic)`);

    // ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯é…åˆ†ã®èª¿æ•´
    await this.adjustTrafficDistribution(stage.percentage);

    // æ®µéšã®ç›£è¦–é–‹å§‹
    const monitoringInterval = setInterval(() => {
      this.monitorStage(stage, stageIndex);
    }, 30000); // 30ç§’é–“éš”

    // æ®µéšã®ç¶™ç¶šæ™‚é–“å¾…æ©Ÿ
    setTimeout(async () => {
      clearInterval(monitoringInterval);
      
      // æˆåŠŸåŸºæº–ã®æœ€çµ‚ãƒã‚§ãƒƒã‚¯
      const success = await this.evaluateSuccessCriteria(stage.successCriteria);
      
      if (success) {
        console.log(`Stage ${stage.name} completed successfully`);
        this.currentDeployment!.stage = stageIndex + 1;
        await this.executeStage(stageIndex + 1);
      } else {
        console.log(`Stage ${stage.name} failed success criteria`);
        await this.rollback('Failed success criteria');
      }
    }, stage.duration * 60000);
  }

  private async adjustTrafficDistribution(percentage: number): Promise<void> {
    // CDN or Load Balancer ã®è¨­å®šã‚’èª¿æ•´
    // ä¾‹ï¼šVercel ã®å ´åˆã¯ Edge Config ã‚’ä½¿ç”¨
    const config = {
      canaryPercentage: percentage,
      timestamp: Date.now()
    };

    await fetch('/api/deployment/traffic-split', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    });
  }

  private async monitorStage(stage: DeploymentStage, stageIndex: number): Promise<void> {
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†
    const metrics = await this.collectDeploymentMetrics();
    
    // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¡ä»¶ã®ãƒã‚§ãƒƒã‚¯
    for (const trigger of this.config.rollbackTriggers) {
      const currentValue = metrics[trigger.metric];
      if (this.shouldTriggerRollback(trigger, currentValue)) {
        await this.rollback(`Rollback triggered: ${trigger.metric} = ${currentValue}`);
        return;
      }
    }

    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹å±¥æ­´ã®æ›´æ–°
    if (this.currentDeployment) {
      for (const [metric, value] of Object.entries(metrics)) {
        if (!this.currentDeployment.metrics[metric]) {
          this.currentDeployment.metrics[metric] = [];
        }
        this.currentDeployment.metrics[metric].push(value);
      }
    }
  }

  private async collectDeploymentMetrics(): Promise<Record<string, number>> {
    // å„ç¨®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†
    const [performanceMetrics, errorMetrics, businessMetrics] = await Promise.all([
      this.getPerformanceMetrics(),
      this.getErrorMetrics(),
      this.getBusinessMetrics()
    ]);

    return {
      ...performanceMetrics,
      ...errorMetrics,
      ...businessMetrics
    };
  }

  private async getPerformanceMetrics(): Promise<Record<string, number>> {
    const response = await fetch('/api/monitoring/performance-summary');
    const data = await response.json();
    
    return {
      averageLCP: data.lcp?.average || 0,
      averageFCP: data.fcp?.average || 0,
      averageResponseTime: data.responseTime?.average || 0,
    };
  }

  private async getErrorMetrics(): Promise<Record<string, number>> {
    const response = await fetch('/api/monitoring/error-summary');
    const data = await response.json();
    
    return {
      errorRate: data.errorRate || 0,
      serverErrorCount: data.serverErrors || 0,
      clientErrorCount: data.clientErrors || 0,
    };
  }

  private async getBusinessMetrics(): Promise<Record<string, number>> {
    const response = await fetch('/api/monitoring/business-summary');
    const data = await response.json();
    
    return {
      conversionRate: data.conversionRate || 0,
      bounceRate: data.bounceRate || 0,
      userSatisfactionScore: data.userSatisfactionScore || 0,
    };
  }

  private shouldTriggerRollback(trigger: RollbackTrigger, currentValue: number): boolean {
    if (!this.currentDeployment) return false;

    const metrics = this.currentDeployment.metrics[trigger.metric] || [];
    
    // æŒ‡å®šã—ãŸç¶™ç¶šæ™‚é–“åˆ†ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
    const recentMetrics = metrics.slice(-Math.ceil(trigger.duration / 30)); // 30ç§’é–“éš”ã®ãƒ‡ãƒ¼ã‚¿
    
    return recentMetrics.length > 0 && 
           recentMetrics.every(value => value > trigger.threshold);
  }

  private async evaluateSuccessCriteria(criteria: SuccessCriteria[]): Promise<boolean> {
    const metrics = await this.collectDeploymentMetrics();
    
    return criteria.every(criterion => {
      const value = metrics[criterion.metric];
      switch (criterion.operator) {
        case 'lt': return value < criterion.threshold;
        case 'gt': return value > criterion.threshold;
        case 'eq': return value === criterion.threshold;
        default: return false;
      }
    });
  }

  private async rollback(reason: string): Promise<void> {
    console.log(`Initiating rollback: ${reason}`);
    
    // ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«æˆ»ã™
    await this.adjustTrafficDistribution(0);
    
    // ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
    alertingSystem.triggerAlert({
      id: 'deployment-rollback',
      name: 'Deployment Rollback',
      metric: 'deployment_status',
      condition: 'eq',
      threshold: 0,
      duration: 0,
      severity: 'critical',
      channels: ['email', 'slack'],
      enabled: true
    }, {
      ruleId: 'deployment-rollback',
      timestamp: Date.now(),
      value: 0,
      severity: 'critical',
      message: `Deployment rollback executed: ${reason}`,
      context: { deploymentId: this.currentDeployment?.id, reason }
    } as any);

    this.currentDeployment = null;
  }
}

// ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨­å®šä¾‹
const productionDeploymentConfig: DeploymentConfig = {
  strategy: 'canary',
  stages: [
    {
      name: 'Canary 5%',
      percentage: 5,
      duration: 10, // 10åˆ†
      successCriteria: [
        { metric: 'errorRate', threshold: 1, operator: 'lt' },
        { metric: 'averageLCP', threshold: 2500, operator: 'lt' }
      ]
    },
    {
      name: 'Canary 25%',
      percentage: 25,
      duration: 15, // 15åˆ†
      successCriteria: [
        { metric: 'errorRate', threshold: 0.5, operator: 'lt' },
        { metric: 'averageLCP', threshold: 2000, operator: 'lt' },
        { metric: 'conversionRate', threshold: 0.95, operator: 'gt' } // å‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®95%ä»¥ä¸Š
      ]
    },
    {
      name: 'Full Rollout',
      percentage: 100,
      duration: 30, // 30åˆ†
      successCriteria: [
        { metric: 'errorRate', threshold: 0.3, operator: 'lt' },
        { metric: 'averageLCP', threshold: 1800, operator: 'lt' }
      ]
    }
  ],
  rollbackTriggers: [
    { metric: 'errorRate', threshold: 5, duration: 300 }, // 5%ã‚’5åˆ†ç¶™ç¶šã§ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
    { metric: 'averageLCP', threshold: 4000, duration: 600 }, // 4ç§’ã‚’10åˆ†ç¶™ç¶šã§ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
  ],
  monitoring: {
    interval: 30,
    metrics: ['errorRate', 'averageLCP', 'averageFCP', 'conversionRate']
  }
};

export const deploymentManager = new DeploymentManager(productionDeploymentConfig);
```

*[å›³è§£4: ã‚«ãƒŠãƒªã‚¢ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼]*
*5%é…ä¿¡ â†’ æˆåŠŸåŸºæº–ãƒã‚§ãƒƒã‚¯ â†’ 25%é…ä¿¡ â†’ 100%é…ä¿¡ â†’ å„æ®µéšã§ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯åˆ¤å®š*

## é•·æœŸçš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«

### 1. å®šæœŸçš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£æŸ»

```typescript
// lib/performance-audit.ts
interface AuditReport {
  timestamp: number;
  version: string;
  scores: {
    lighthouse: LighthouseScores;
    webVitals: WebVitalsScores;
    customMetrics: CustomMetricsScores;
  };
  recommendations: Recommendation[];
  trends: TrendAnalysis;
}

interface Recommendation {
  category: 'performance' | 'accessibility' | 'seo' | 'best-practices';
  priority: 'high' | 'medium' | 'low';
  title: string;
  description: string;
  impact: 'high' | 'medium' | 'low';
  effort: 'high' | 'medium' | 'low';
  implementation: {
    steps: string[];
    estimatedTime: string;
    resources: string[];
  };
}

class PerformanceAuditor {
  private auditHistory: AuditReport[] = [];

  public async runComprehensiveAudit(): Promise<AuditReport> {
    console.log('Starting comprehensive performance audit...');

    const [lighthouseResults, webVitalsData, customMetrics] = await Promise.all([
      this.runLighthouseAudit(),
      this.analyzeWebVitals(),
      this.gatherCustomMetrics()
    ]);

    const report: AuditReport = {
      timestamp: Date.now(),
      version: process.env.APP_VERSION || '1.0.0',
      scores: {
        lighthouse: lighthouseResults,
        webVitals: webVitalsData,
        customMetrics: customMetrics
      },
      recommendations: await this.generateRecommendations(lighthouseResults, webVitalsData, customMetrics),
      trends: this.analyzeTrends()
    };

    this.auditHistory.push(report);
    
    // ãƒ¬ãƒãƒ¼ãƒˆã®ä¿å­˜ã¨å…±æœ‰
    await this.saveAuditReport(report);
    await this.notifyStakeholders(report);

    return report;
  }

  private async runLighthouseAudit(): Promise<LighthouseScores> {
    // Lighthouse CI ã¾ãŸã¯ puppeteer ã‚’ä½¿ç”¨ã—ãŸç›£æŸ»
    const lighthouse = require('lighthouse');
    const chromeLauncher = require('chrome-launcher');

    const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] });
    const options = {
      logLevel: 'info',
      output: 'json',
      onlyCategories: ['performance', 'accessibility', 'best-practices', 'seo'],
      port: chrome.port,
    };

    const runnerResult = await lighthouse(process.env.AUDIT_URL!, options);
    await chrome.kill();

    return {
      performance: runnerResult.lhr.categories.performance.score * 100,
      accessibility: runnerResult.lhr.categories.accessibility.score * 100,
      bestPractices: runnerResult.lhr.categories['best-practices'].score * 100,
      seo: runnerResult.lhr.categories.seo.score * 100,
      audits: runnerResult.lhr.audits
    };
  }

  private async analyzeWebVitals(): Promise<WebVitalsScores> {
    // éå»30æ—¥é–“ã®Web Vitalsãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æ
    const response = await fetch('/api/monitoring/web-vitals-summary?days=30');
    const data = await response.json();

    return {
      fcp: {
        p75: data.fcp.percentiles.p75,
        average: data.fcp.average,
        score: this.calculateWebVitalScore('fcp', data.fcp.percentiles.p75)
      },
      lcp: {
        p75: data.lcp.percentiles.p75,
        average: data.lcp.average,
        score: this.calculateWebVitalScore('lcp', data.lcp.percentiles.p75)
      },
      cls: {
        p75: data.cls.percentiles.p75,
        average: data.cls.average,
        score: this.calculateWebVitalScore('cls', data.cls.percentiles.p75)
      },
      fid: {
        p75: data.fid.percentiles.p75,
        average: data.fid.average,
        score: this.calculateWebVitalScore('fid', data.fid.percentiles.p75)
      }
    };
  }

  private calculateWebVitalScore(metric: string, value: number): number {
    const thresholds = {
      fcp: { good: 1800, needsImprovement: 3000 },
      lcp: { good: 2500, needsImprovement: 4000 },
      cls: { good: 0.1, needsImprovement: 0.25 },
      fid: { good: 100, needsImprovement: 300 }
    };

    const threshold = thresholds[metric as keyof typeof thresholds];
    if (value <= threshold.good) return 100;
    if (value <= threshold.needsImprovement) return 50;
    return 0;
  }

  private async generateRecommendations(
    lighthouse: LighthouseScores,
    webVitals: WebVitalsScores,
    customMetrics: CustomMetricsScores
  ): Promise<Recommendation[]> {
    const recommendations: Recommendation[] = [];

    // Lighthouseã®æ”¹å–„ææ¡ˆã‹ã‚‰ç”Ÿæˆ
    for (const [auditId, audit] of Object.entries(lighthouse.audits)) {
      if (audit.score !== null && audit.score < 0.9 && audit.details?.type === 'opportunity') {
        recommendations.push({
          category: 'performance',
          priority: audit.details.overallSavingsMs > 1000 ? 'high' : 'medium',
          title: audit.title,
          description: audit.description,
          impact: audit.details.overallSavingsMs > 1000 ? 'high' : 'medium',
          effort: this.estimateImplementationEffort(auditId),
          implementation: this.getImplementationGuidance(auditId)
        });
      }
    }

    // Web Vitalsã®æ”¹å–„ææ¡ˆ
    if (webVitals.lcp.score < 75) {
      recommendations.push({
        category: 'performance',
        priority: 'high',
        title: 'Improve Largest Contentful Paint',
        description: `LCP is ${webVitals.lcp.p75}ms, which needs improvement. Target: <2500ms`,
        impact: 'high',
        effort: 'medium',
        implementation: {
          steps: [
            'Optimize critical resource loading',
            'Implement resource preloading',
            'Optimize server response times',
            'Consider using SSG/ISR for static content'
          ],
          estimatedTime: '1-2 weeks',
          resources: ['Performance engineer', 'Frontend developer']
        }
      });
    }

    return recommendations.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
  }

  private estimateImplementationEffort(auditId: string): 'high' | 'medium' | 'low' {
    const highEffortAudits = ['unused-javascript', 'render-blocking-resources', 'critical-request-chains'];
    const lowEffortAudits = ['efficient-animated-content', 'uses-optimized-images'];

    if (highEffortAudits.includes(auditId)) return 'high';
    if (lowEffortAudits.includes(auditId)) return 'low';
    return 'medium';
  }

  private getImplementationGuidance(auditId: string): { steps: string[]; estimatedTime: string; resources: string[] } {
    const guidance = {
      'unused-javascript': {
        steps: [
          'Analyze bundle using webpack-bundle-analyzer',
          'Implement code splitting with dynamic imports',
          'Remove unused dependencies',
          'Configure tree shaking optimization'
        ],
        estimatedTime: '2-3 weeks',
        resources: ['Frontend developer', 'DevOps engineer']
      },
      'uses-optimized-images': {
        steps: [
          'Implement Next.js Image component',
          'Configure automatic WebP/AVIF conversion',
          'Set up responsive image sizing',
          'Add lazy loading for below-the-fold images'
        ],
        estimatedTime: '3-5 days',
        resources: ['Frontend developer']
      }
    };

    return guidance[auditId as keyof typeof guidance] || {
      steps: ['Analyze the specific audit requirements', 'Plan implementation approach', 'Implement and test changes'],
      estimatedTime: '1 week',
      resources: ['Frontend developer']
    };
  }

  private analyzeTrends(): TrendAnalysis {
    if (this.auditHistory.length < 2) {
      return { direction: 'stable', changes: [] };
    }

    const current = this.auditHistory[this.auditHistory.length - 1];
    const previous = this.auditHistory[this.auditHistory.length - 2];

    const changes = [
      {
        metric: 'Performance Score',
        current: current.scores.lighthouse.performance,
        previous: previous.scores.lighthouse.performance,
        change: current.scores.lighthouse.performance - previous.scores.lighthouse.performance
      },
      {
        metric: 'LCP (p75)',
        current: current.scores.webVitals.lcp.p75,
        previous: previous.scores.webVitals.lcp.p75,
        change: current.scores.webVitals.lcp.p75 - previous.scores.webVitals.lcp.p75
      }
    ];

    const overallTrend = changes.reduce((sum, change) => sum + change.change, 0);
    
    return {
      direction: overallTrend > 5 ? 'improving' : overallTrend < -5 ? 'declining' : 'stable',
      changes
    };
  }

  private async saveAuditReport(report: AuditReport): Promise<void> {
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«ä¿å­˜
    await fetch('/api/monitoring/audit-reports', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(report)
    });
  }

  private async notifyStakeholders(report: AuditReport): Promise<void> {
    // ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼ã¸ã®é€šçŸ¥
    const summary = this.generateReportSummary(report);
    
    await fetch('/api/notifications/audit-report', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        recipients: process.env.AUDIT_REPORT_RECIPIENTS?.split(',') || [],
        subject: `Performance Audit Report - ${new Date().toISOString().split('T')[0]}`,
        content: summary
      })
    });
  }

  private generateReportSummary(report: AuditReport): string {
    const highPriorityRecommendations = report.recommendations.filter(r => r.priority === 'high');
    
    return `
# Performance Audit Report

## Executive Summary
- **Performance Score**: ${report.scores.lighthouse.performance}/100
- **LCP**: ${report.scores.webVitals.lcp.p75}ms
- **FCP**: ${report.scores.webVitals.fcp.p75}ms
- **CLS**: ${report.scores.webVitals.cls.p75}

## Trends
Direction: ${report.trends.direction}

## High Priority Recommendations (${highPriorityRecommendations.length})
${highPriorityRecommendations.map(r => `- ${r.title}: ${r.description}`).join('\n')}

## Next Steps
Please review the full report for detailed implementation guidance.
    `;
  }
}

// å®šæœŸç›£æŸ»ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
export const performanceAuditor = new PerformanceAuditor();

// é€±æ¬¡ç›£æŸ»ã®è‡ªå‹•å®Ÿè¡Œ
if (process.env.NODE_ENV === 'production') {
  setInterval(async () => {
    try {
      await performanceAuditor.runComprehensiveAudit();
    } catch (error) {
      console.error('Scheduled performance audit failed:', error);
    }
  }, 7 * 24 * 60 * 60 * 1000); // 7æ—¥é–“éš”
}
```

*[å›³è§£5: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«]*
*ç›£æŸ»å®Ÿè¡Œ â†’ å•é¡Œç‰¹å®š â†’ æ”¹å–„è¨ˆç”» â†’ å®Ÿè£… â†’ åŠ¹æœæ¸¬å®š â†’ æ¬¡å›ç›£æŸ»*

## ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒã‚¤ãƒ³ãƒˆ

- **RUMç›£è¦–**: ãƒªã‚¢ãƒ«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚‹ç¶™ç¶šçš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŠŠæ¡
- **æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤**: ã‚«ãƒŠãƒªã‚¢ãƒªãƒªãƒ¼ã‚¹ã«ã‚ˆã‚‹å®‰å…¨ãªæœ¬ç•ªé©ç”¨
- **è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆ**: å•é¡Œã®æ—©æœŸç™ºè¦‹ã¨è¿…é€Ÿãªå¯¾å¿œ
- **æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«**: å®šæœŸç›£æŸ»ã«ã‚ˆã‚‹é•·æœŸçš„ãªå“è³ªå‘ä¸Š

## ã‚·ãƒªãƒ¼ã‚ºã¾ã¨ã‚

4å›ã«ã‚ãŸã£ã¦ã€Next.jsæœ€é€Ÿãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®æ”»é˜²ã«ã¤ã„ã¦å­¦ã‚“ã§ãã¾ã—ãŸã€‚

**ç¬¬1å›**ã§ã¯ã€Pages Routerã‹ã‚‰App Routerã¸ã®å®‰å…¨ãªç§»è¡Œæˆ¦ç•¥ã‚’ã€‚**ç¬¬2å›**ã§ã¯ã€CSR/SSR/SSG/ISRã®é¸æŠåŸºæº–ã¨styled-componentsæœ€é©åŒ–ã‚’ã€‚**ç¬¬3å›**ã§ã¯ã€dev.toç´šãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å®Ÿç¾ã®å…·ä½“çš„å®Ÿè£…ã‚’ã€‚ãã—ã¦ä»Šå›ã¯ã€æœ¬ç•ªç’°å¢ƒã§ã®å®‰å®šé‹ç”¨ã«ã¤ã„ã¦è©³ã—ãã”ç´¹ä»‹ã—ã¾ã—ãŸã€‚

é‡è¦ãªã®ã¯ã€**æŠ€è¡“çš„ãªæœ€é©åŒ–ã¨ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ã®å‘ä¸Šã‚’ä¸¡ç«‹ã•ã›ã‚‹ã“ã¨**ã€‚ãã—ã¦ã€ä¸€åº¦æœ€é©åŒ–ã™ã‚Œã°çµ‚ã‚ã‚Šã§ã¯ãªãã€ç¶™ç¶šçš„ãªç›£è¦–ã¨æ”¹å–„ã‚’ç¶šã‘ã‚‹ã“ã¨ã§ã™ã€‚ãã‚Œã¯æŠ€è¡“è€…ã¨ã—ã¦ã®è²¬ä»»ã§ã‚‚ã‚ã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã•ã‚“ã¸ã®æ€ã„ã‚„ã‚Šã§ã‚‚ã‚ã‚‹ã€ã¤ã¾ã‚ŠæŒç¶šå¯èƒ½ãªé–‹ç™ºã®æœ¬è³ªã£ã¦ã‚ã‘ã­ã€‚

æ°—åˆ†ã‚’å®³ã•ã‚ŒãŸã‚‰ã”ã‚ã‚“ãªã•ã„ã€ã§ã‚‚ç§ã¨ã—ã¦ã¯ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¯å˜ãªã‚‹æŠ€è¡“çš„ãªå–ã‚Šçµ„ã¿ã§ã¯ãªãã€ã‚ˆã‚Šè‰¯ã„Webä½“é¨“ã‚’æä¾›ã™ã‚‹ãŸã‚ã®å¤§åˆ‡ãªæ´»å‹•ã ã¨æ€ã„ã¾ã™ã€‚

ã“ã®ã‚·ãƒªãƒ¼ã‚ºãŒã€çš†æ§˜ã®Next.jsãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§dev.toç´šã®é«˜é€Ÿã‚µã‚¤ãƒˆã‚’å®Ÿç¾ã™ã‚‹åŠ©ã‘ã«ãªã‚Œã°å¹¸ã„ã§ã™ã€‚èª­è€…ã®çš†æ§˜ã€é•·ã„é–“ãŠä»˜ãåˆã„ã„ãŸã ãã€æœ¬å½“ã«ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚

---

**ğŸ¤– AIç”Ÿæˆè¨˜äº‹ã«ã¤ã„ã¦**
ã“ã®è¨˜äº‹ã¯Claude (Anthropic) ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚æŠ€è¡“çš„å†…å®¹ã«ã¤ã„ã¦ã¯2025å¹´8æœˆæ™‚ç‚¹ã®æƒ…å ±ã«åŸºã¥ã„ã¦ãŠã‚Šã€æœ¬ç•ªé‹ç”¨ã§ã®å®Ÿè·µçš„ãªç›£è¦–ãƒ»é‹ç”¨æ‰‹æ³•ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚

**ğŸ“ åŸ·ç­†è€…**: youkoï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒ»UI/UXãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼ï¼‰  
**ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼**: alexandra_sterlingï¼ˆã‚·ãƒ‹ã‚¢ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆï¼‰ã«ã‚ˆã‚‹æŠ€è¡“çš„æ­£ç¢ºæ€§ãƒã‚§ãƒƒã‚¯æ¸ˆã¿  
**ğŸ“Š ã‚·ãƒªãƒ¼ã‚º**: Next.jsæœ€é€Ÿãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®æ”»é˜²ï¼ˆå…¨4å›ï¼‰- **å®Œçµ**